# LeetCode
力扣编程题训练

---------------------------------------------------------------

## 1-628 三个数的最大乘积
### 思路
最大乘积的可能情况   

1. 三个非负数相乘（**最大的三个数**）
2. 两个非负数和一个负数（这种情况下数组只有这三个数）
3. 一个非负数和两个负数（**最小的两个和最大的数**）
4. 三个负数（数组都是负数，**最大的三个数**）

所以，只要求出两个可能的乘积，比较一下大小就行

### 题解
+ 将数组排序，找到五个数num[size-1],num[size-2],num[size-3],num[1],num[0]
  + 时间复杂度 - 排序的时间复杂度
  + 空间复杂度 - O(1)
+ 不用排序算法，直接遍历数组，找出最大的三个数和最小的两个数
  + 时间复杂度 -  O(n)
  + 空间复杂度 - O(1)



## 1-2 两数相加
### 思路
和小时候做两数相加流程一致，维护一个进位int，每次从l1或l2取一个或l1和l2取两个数，和前一轮的进位相加，模10存入结果当前位，除10作为下一轮的进位，如果l1和l2都结束了且进位为0，不再创建新的结果位

### 优化
这里我将结果存入了新开辟的空间内，可以尝试优化直接将结果存在给的两个ListNode里，节省空间开销

---------------------------------------------------------------

## 2-5 最长回文子串
### 思路
#### 1 - 暴力穷举
两层循环找到所有的子串，判断是否回文，再记录最长的回文子串
时间复杂度O(n^3)

#### 2 - 中心扩展
1. 先将字符串预处理，用``#``对字符串进行填充
2. 在新得到的字符串中，将每个字符作为回文串的中心，向两边扩展
3. 对所有的回文子串进行长度判断，找出最长回文子串

时间复杂度O(n^2)

#### 3 - Manacher算法
根据回文字符串的特性，具有左右对称性，该算法目的就是拓展当前已知回文子串的右边界及其中心，维护一个p[]:以i为回文中心的回文串的半径
1. 先将字符串预处理，abcdada -> #a#b#c#d#a#d#a#
   + abb -> a#b#b 会有问题
2. 对新字符串中的每个字符进行操作
   + 如果i > 右边界,以i为中心，进行回文子串判断，更新右边界
   + 如果i < 右边界，找到i与当前右边界对应的中心对称的j，查找p[j]
     + 如果i+p[j] < 右边界，可知以i为中心的回文长度应等于p[j]
     + 如果i+p[j] > 右边界，则需要以i为中心重新判断回文，更新右边界
3. 根据p[]，得到最长的回文子串

时间复杂度O(n)


---------------------------------------------------------------

## 3-3 无重复字符的最长子串
### 思路
#### 1.暴力穷举
每个字符最为子串头，找到所有的无重复字符的子串，得到最长子串的长度
时间复杂度O(n^2)

#### 2-滑动窗口
维护一个result，值为无重复字符的最长子串的长度
维护一个队列，每加进一个字符c，判断原队列是否存在该字符c
 + 存在：找到该字符在队列的位置i，i之前包括i位置的字符清出队列，将c加入队列，
 + 不存在：将该字符加入队列，判断队列长度与result的大小，更新，继续下一个    

时间复杂度O(n)

